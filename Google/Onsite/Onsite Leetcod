【谷歌面经讨论】
https://docs.google.com/document/d/1qxA2wps0IhVRWULulQ55W4SGPMu2AE5MkBB37h8Dr58/edit

130 Surrounded Regions

146

375

输入matrix，找最长递增路径

410

n-ary tree 最长路径

A tree with n nodes can be uniquely expressed by a sequence of n-2 integer numbers (in the range of [0, n-1]). This is called the Prüfer sequence.”
(skiplist) (http://www.cs.utsa.edu/~wagner/knuth/fasc4a.pdf, table1)

array snapshot

valid parenthesis

patition n task into k days to minimize the amount of resources used per day, usage per day is the same, task must be completed sequentially
(lc 437)

lc158

lc947

snake and ladder

Morris Traversal Iterator

kmp

https://stackoverflow.com/questions/16402854/number-of-increasing-subsequences-of-length-k

汇率转换(union find)(lc 399)

人车匹配。x-y平面上把人和車做配對。人找最近的車子，求配對結果

merge k linkedlist

给一个prefix，返回一个word list包含所有该前缀的words。应该用Trie就行

decompression string

Big Integer 实现add功能
(数组计算)

一个board，0表示水，1表示陆地。水的高度为0，限制相邻格子的高度差不超过1，求board上最大高度
(先遍历，找到所有0，把位置push into queue。有一个变量H记录正在处理的高度，初始为1.
 然后queue里面的每弹出来一个，就把它周围未被赋值的赋值为H，并且把这个位置push into queue。
 每一次循环H++，直到queue为空退出。
 复杂度Omn吧)

完全二叉树，判断index是否有效，求二叉树的节点个数

兩個list各有不同數字，求他們的difference數字有哪些，同樣數字互相抵消，所以output一個list裡面是兩個list不同的數字。舉例：A[1,1,2,3,4] B[1,4,5,6]，答案是[1,2,3,5,6]

输入一个矩阵， 将每个点更新成上下左右的和

0～ N个灯泡，
(支持两个操作，1.flip(start, end), 将start至end这个区间灯泡状态flip,   开的变关的，关的变开的。2.查询index i 处的灯泡是否亮着
这一轮，韩国大哥疯狂提示，我一开始用range module的思路想的，重叠部分，直接删除，因为flip两遍相当于没有。他说太复杂。
韩国大哥给了个property,   说flip(start, end) = flip(0, start - 1) + flip(0, end).   以及如果有奇数个interval覆盖一个点，这个灯泡就是亮的，否则是暗的。
所以可以，BST存所有端点，每次查询时，看比他大的端点有是奇数个还是偶数个就可以了。)


设计一个类似于Intellij的自动补全功能
  比如说有很多文件名， [FooBaaBoo, FooBoo], 如果我给出FB, FooB, Foo, FBB，返回两个文件名，如果给出FooBa返回FooBaaBoo，如果给出oo什么都不返回
  文件名有很多，query次数很多，如何能用高效解决
(可以用两个Trie, 一个trie存文件名prefix, 一个trie存文件名的大写字母； trie上面的每个node都存对应的文件名，（为了省空间，可以存每个文件名的对应的index）
比如文件[FooBaaBoo, FooBoo],  FooBaaBoo 对应index 0, FooBoo 对应index 1; (当然也可以用hash function的方法计算得到index)
优化的话，可以对trie进行compact, 或者建立bloom filter去除无用的search)


Round 2:  step 1: 给出一个List<Integer>, 写一个iterator，写一个iterator来遍历其中所有的偶数 e.g. [1, 3, 7, 9, 11, 12, 13, 2, 1], 可以遍历[12, 2]
  step 2: 给出一个List<Integer>, 每两个数为一组，分别表示次数和数字，假定list中的数字数量永远为偶数，写一个iterator来展开它所表示的数字  e.g. [1,3,2,7] (表示3出现一遍，7出现2遍), 遍历结果[3, 7, 7]
  step 3: List<List<Integer>>, 要求每次从每个inner list中取一个数字，直到遍历完  e.g. [[1, 2], [3], [1, 5, 7], [2, 4]] 遍历结果是[1, 3, 1, 2, 2, 5, 4, 7]


